<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Fantasy SPL Manager Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- html2canvas library for capturing screenshots -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> 
    <!-- NEW: gif.js library for GIF encoding -->
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Oswald:wght@400;700&display=swap" rel="stylesheet">
    <style id="main-styles">
        /* Base colors for light mode (current default) */
        :root {
            --spl-light-bg: #F8F9FA;
            --spl-container-bg: #FFFFFF;
            --spl-table-bg: #E0E4E8;
            --spl-table-header-bg: #B3D9FF;
            --spl-table-row-even: #D6DBE0;
            --spl-table-row-hover: #C7CCD1;
            --spl-text-dark: #212529;
            --spl-text-medium: #495057;
            --spl-primary-accent: #034667;
            --spl-accent-green: #28A745;
            --spl-accent-red: #DC3545;
            --spl-border-light: #CED4DA;
            --spl-shadow: rgba(0, 0, 0, 0.1);
        }

        /* Dark mode specific variables */
        body.dark-mode {
            --spl-light-bg: #034667; /* User requested background */
            --spl-container-bg: #1a3e5c; /* Darker blue for cards/containers */
            --spl-table-bg: #0d283c; /* Even darker blue for tables */
            --spl-table-header-bg: #0a1c2a; /* Very dark blue/black for table headers */
            --spl-table-row-even: #123045; /* Dark blue for even rows */
            --spl-table-row-hover: #1f4f7a; /* Lighter dark blue on hover */
            --spl-text-dark: #F8F9FA; /* Light text */
            --spl-text-medium: #CED4DA; /* Lighter medium text */
            --spl-primary-accent: #007bff; /* Brighter blue for accent */
            /* Green and Red accents remain the same for clarity */
            --spl-border-light: #495057; /* Darker border */
            --spl-shadow: rgba(255, 255, 255, 0.1); /* Light shadow for dark mode */
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--spl-light-bg);
            color: var(--spl-text-dark);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition for theme change */
        }

        #logo-container {
            text-align: center;
            margin-bottom: 20px; /* Space below the logo */
            width: 100%;
        }

        #logo-container img {
            max-width: 300px; /* Adjust as needed for PC size */
            height: auto;
            display: block; /* Remove extra space below image */
            margin: 0 auto; /* Center the image */
            transition: src 0.3s ease; /* Smooth transition for logo change */
        }

        /* Theme switch styles */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            justify-content: center; /* Center the switch */
            margin-bottom: 20px;
            gap: 10px;
            color: var(--spl-text-dark); /* Ensure label text changes with theme */
            font-size: 0.95em;
            width: 100%; /* Take full width to help centering */
            max-width: 1200px; /* Align with container max width */
        }
        .theme-switch {
            position: relative;
            display: inline-block;
            width: 45px;
            height: 25px;
        }
        .theme-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: var(--spl-primary-accent);
        }
        input:focus + .slider {
            box-shadow: 0 0 1px var(--spl-primary-accent);
        }
        input:checked + .slider:before {
            -webkit-transform: translateX(20px);
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }
        /* Rounded sliders */
        .slider.round {
            border-radius: 25px;
        }
        .slider.round:before {
            border-radius: 50%;
        }
        /* Adjust switch background color for dark mode */
        body.dark-mode .theme-switch .slider {
            background-color: #555; /* Darker grey when off in dark mode */
        }
        body.dark-mode input:checked + .slider {
            background-color: var(--spl-primary-accent); /* Brighter blue when on in dark mode */
        }
        body.dark-mode .theme-label {
            color: var(--spl-text-dark); /* Ensure label color changes correctly in dark mode */
        }


        .container {
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            box-shadow: 0 6px 12px var(--spl-shadow);
            padding: 30px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
            transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition */
        }

        h1, h2, h3 {
            font-family: 'Oswald', sans-serif;
            color: var(--spl-primary-accent);
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            transition: color 0.3s ease; /* Smooth transition */
        }
        
        /* Specific style for the main manager name/rank header */
        #managerName {
            font-size: 2em; /* Adjust as needed */
            line-height: 1.3;
            margin-bottom: 30px;
            color: var(--spl-text-dark); /* Darker text for main header */
            text-align: center;
            transition: color 0.3s ease; /* Smooth transition */
        }
        #managerName span {
            color: var(--spl-primary-accent); /* Accent color for the actual name */
            transition: color 0.3s ease; /* Smooth transition */
        }


        .input-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .input-section label {
            font-weight: bold;
            color: var(--spl-text-medium);
            font-size: 1.1em;
            transition: color 0.3s ease; /* Smooth transition */
        }

        .input-section input[type="text"] {
            padding: 12px 15px;
            border: 1px solid var(--spl-border-light);
            border-radius: 8px;
            font-size: 1em;
            width: 100%;
            max-width: 300px;
            box-sizing: border-box;
            text-align: center;
            background-color: var(--spl-container-bg); /* Match container background */
            color: var(--spl-text-dark); /* Match text color */
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Smooth transition */

            /* Hide spinner arrows for number input (even though type is text now, some browsers might add them if it looks like a number) */
            -moz-appearance: textfield; /* Firefox */
        }
        /* Webkit browsers (Chrome, Safari, Edge) for hiding arrows */
        .input-section input::-webkit-outer-spin-button,
        .input-section input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }


        .input-section button { /* Base style for all buttons in input section */
            background-color: var(--spl-primary-accent);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; /* Smooth transition */
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
            width: 100%;
            max-width: 300px;
            display: block;
            margin: 0 auto; /* Center the button */
        }

        .input-section button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }

        /* Styles for the Rank Journey button container */
        .rank-journey-box {
            background-color: var(--spl-primary-accent); /* Dark blue background */
            border-radius: 12px;
            box-shadow: 0 8px 16px var(--spl-shadow); /* Use shadow variable */
            padding: 25px;
            margin: 30px auto; /* Center the box horizontally */
            text-align: center;
            width: 100%;
            max-width: 400px; /* Adjust max width for the box */
            box-sizing: border-box;
            display: none; /* Hidden by default, shown with manager stats */
            flex-direction: column; /* Ensure content stacks vertically */
            align-items: center; /* Center content horizontally within the box */
            transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition */
        }

        .rank-journey-box h3 {
            color: white; /* White text for the title inside the box */
            font-family: 'Oswald', sans-serif;
            font-size: 1.8em; /* Large and prominent title */
            margin-top: 0;
            margin-bottom: 20px; /* Space between title and button */
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: color 0.3s ease; /* Smooth transition */
        }

        /* Styles for the button inside the Rank Journey box */
        #createRankJourneyButton { /* Reusing the ID, applying new styles */
            background-color: white; /* White background */
            color: var(--spl-primary-accent); /* Dark blue text */
            padding: 15px 35px; /* More padding */
            border: none; /* No border for a cleaner look */
            border-radius: 10px; /* Rounded corners */
            font-size: 1.2em; /* Larger font */
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow */
            cursor: pointer;
            transition: all 0.3s ease;
            width: auto; /* Allow button to size based on content */
            display: inline-block; /* Allow it to be centered easily */
        }

        #createRankJourneyButton:hover {
            background-color: #f0f0f0; /* Slightly grey on hover */
            color: #0056b3; /* Slightly darker blue text on hover */
            transform: translateY(-2px); /* Slight lift */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25); /* Slightly larger shadow */
        }

        /* Share Video Button Specific Styles */
        #shareVideoButton {
            background-color: #17A2B8; /* A vibrant blue for sharing */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 8px rgba(23, 162, 184, 0.2);
            width: 100%;
            max-width: 300px;
            display: block;
            margin: 15px auto 0 auto; /* Margin top to separate from analyze button */
            text-align: center;
        }

        #shareVideoButton:hover {
            background-color: #138496;
            transform: translateY(-2px);
        }
        body.dark-mode #shareVideoButton {
            background-color: #20c997; /* Teal for dark mode share button */
            box-shadow: 0 4px 8px rgba(32, 201, 151, 0.2);
        }
        body.dark-mode #shareVideoButton:hover {
            background-color: #1aae88;
        }

        /* Compatibility Warning Message */
        #compatibilityWarning {
            background-color: #ffe0e6; /* Light red/pink */
            color: #DC3545; /* Dark red text */
            border: 1px solid #DC3545;
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px; /* Space above */
            margin-bottom: 20px; /* Space below button */
            font-weight: bold;
            display: none; /* Hidden by default */
            width: 100%;
            max-width: 600px; /* Aligned with instructions box */
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        body.dark-mode #compatibilityWarning {
            background-color: #58161f; /* Darker red */
            color: #ffcdd2; /* Lighter red text */
            border-color: #9b1e2e;
        }


        .loading-message, .error-message, .video-loading-message, #videoGeneratingMessage { /* Added #videoGeneratingMessage */
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: bold;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }

        .loading-message {
            background-color: #e0f7fa;
            color: #007BFF;
        }

        .error-message {
            background-color: #ffe0e6;
            color: #DC3545;
            border: 1px solid #DC3545;
        }

        .video-loading-message {
            background-color: #fff3cd;
            color: #856404;
            display: none; /* Hidden by default */
        }
        /* Style for the new video generation loading message */
        #videoGeneratingMessage {
            background-color: #cfe2ff; /* Light blue */
            color: #0056b3; /* Dark blue text */
            display: none; /* Hidden by default */
        }
        body.dark-mode #videoGeneratingMessage {
            background-color: #0a1c2a; /* Dark background */
            color: #ffffff; /* White text */
        }


        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .stat-card {
            background-color: var(--spl-table-bg); /* Use a slightly darker background for cards */
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px var(--spl-shadow); /* Use shadow variable */
            text-align: center;
            transition: transform 0.2s ease, background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition */
        }

        .stat-card:hover {
            transform: translateY(-3px);
        }

        .stat-card h3 {
            color: var(--spl-primary-accent);
            margin-top: 0;
            font-size: 1.3em;
            margin-bottom: 10px;
            transition: color 0.3s ease; /* Smooth transition */
        }

        .stat-card p {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--spl-text-dark);
            margin: 0;
            transition: color 0.3s ease; /* Smooth transition */
        }

        .stat-card .small-text {
            font-size: 0.9em;
            color: var(--spl-text-medium);
            margin-top: 5px;
            transition: color 0.3s ease; /* Smooth transition */
        }

        .chart-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            box-shadow: 0 6px 12px var(--spl-shadow);
            display: flex;
            flex-direction: column;
            align-items: center; /* Center horizontally */
            transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition */
        }

        .chart-section h2 {
            margin-bottom: 20px;
        }

        #rankJourneyChart {
            width: 100%; /* Take full width of its container */
            max-width: 900px; /* Limit max width on large screens */
            height: auto; /* Height will be controlled by aspect ratio in JS */
            box-sizing: border-box;
        }

        .table-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            box-shadow: 0 6px 12px var(--spl-shadow);
            transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition */
        }

        .table-section h2 {
            margin-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            table-layout: fixed; /* Ensures columns respect defined widths */
        }

        th, td {
            padding: 12px 15px;
            border: 1px solid var(--spl-border-light);
            text-align: left;
            word-break: break-word; /* Allow long words to break */
            white-space: normal; /* Ensure text wraps */
            transition: border-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }

        th {
            background-color: var(--spl-table-header-bg);
            color: var(--spl-text-dark);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9em;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }

        tr:nth-child(even) {
            background-color: var(--spl-table-row-even);
        }

        tr:hover {
            background-color: var(--spl-table-row-hover);
        }

        .positive {
            color: var(--spl-accent-green);
            font-weight: bold;
        }

        .negative {
            color: var(--spl-accent-red);
            font-weight: bold;
        }

        /* Responsive Adjustments */
        @media (min-width: 951px) {
            #topCaptainsTable th:nth-child(1), #topCaptainsTable td:nth-child(1) { width: auto; }
            #topCaptainsTable th:nth-child(2), #topCaptainsTable td:nth-child(2) { width: auto; }
            #topCaptainsTable th:nth-child(3), #topCaptainsTable td:nth-child(3) { width: auto; }
            #topCaptainsTable th:nth-child(4), #topCaptainsTable td:nth-child(4) { width: auto; }
            #topCaptainsTable th:nth-child(5), #topCaptainsTable td:nth-child(5) { width: auto; }
            #topCaptainsTable th:nth-child(6), #topCaptainsTable td:nth-child(6) { width: auto; }

            #bestPlayersTable th:nth-child(1), #bestPlayersTable td:nth-child(1) { width: auto; }
            #bestPlayersTable th:nth-child(2), #bestPlayersTable td:nth-child(2) { width: auto; }
            #bestPlayersTable th:nth-child(3), #bestPlayersTable td:nth-child(3) { width: auto; }
            #bestPlayersTable th:nth-child(4), #bestPlayersTable td:nth-child(4) { width: auto; }
            #bestPlayersTable th:nth-child(5), #bestPlayersTable td:nth-child(5) { width: auto; }

            #worstPlayersTable th:nth-child(1), #worstPlayersTable td:nth-child(1) { width: auto; }
            #worstPlayersTable th:nth-child(2), #worstPlayersTable td:nth-child(2) { width: auto; }
            #worstPlayersTable th:nth-child(3), #worstPlayersTable td:nth-child(3) { width: auto; }
            #worstPlayersTable th:nth-child(4), #worstPlayersTable td:nth-child(4) { width: auto; }
            #worstPlayersTable th:nth-child(5), #worstPlayersTable td:nth-child(5) { width: auto; }

            #missedPointsTable th:nth-child(1), #missedPointsTable td:nth-child(1) { width: auto; }
            #missedPointsTable th:nth-child(2), #missedPointsTable td:nth-child(2) { width: auto; }
            #missedPointsTable th:nth-child(3), #missedPointsTable td:nth-child(3) { width: auto; }

            #profitableTransfersTable th:nth-child(1), #profitableTransfersTable td:nth-child(1) { width: auto; }
            #profitableTransfersTable th:nth-child(2), #profitableTransfersTable td:nth-child(2) { width: auto; }
            #profitableTransfersTable th:nth-child(3), #profitableTransfersTable td:nth-child(3) { width: auto; }
            #profitableTransfersTable th:nth-child(4), #profitableTransfersTable td:nth-child(4) { width: auto; }

            #lossMakingTransfersTable th:nth-child(1), #lossMakingTransfersTable td:nth-child(1) { width: auto; }
            #lossMakingTransfersTable th:nth-child(2), #lossMakingTransfersTable td:nth-child(2) { width: auto; }
            #lossMakingTransfersTable th:nth-child(3), #lossMakingTransfersTable td:nth-child(3) { width: auto; }
            #lossMakingTransfersTable th:nth-child(4), #lossMakingTransfersTable td:nth-child(4) { width: auto; }
        }


        /* Mobile Version (apply when viewport is 950px or narrower) */
        @media (max-width: 950px) {
            body {
                padding: 15px;
            }

            .container {
                padding: 20px;
            }

            .input-section input[type="text"],
            .input-section button {
                font-size: 0.95em;
                padding: 10px 20px;
            }

            .stats-grid {
                grid-template-columns: 1fr; /* Stack cards on small screens */
            }

            .stat-card p {
                font-size: 1.5em;
            }

            /* Apply card-like display to ALL tables */
            table {
                border: 0;
            }

            table thead {
                display: none; /* Hide table headers */
            }

            table tr {
                display: block;
                margin-bottom: 10px;
                border: 1px solid var(--spl-border-light);
                border-radius: 8px;
                background-color: var(--spl-container-bg); /* Card background */
                box-shadow: 0 2px 4px var(--spl-shadow); /* Use shadow variable */
                padding: 10px;
            }

            table td {
                display: block;
                text-align: right;
                padding: 8px 10px;
                border: none; /* Remove cell borders */
                border-bottom: 1px solid var(--spl-table-row-even); /* Separator for cells */
                position: relative; /* For pseudo-element positioning */
                font-size: 0.9em; /* Adjust font size for mobile cells */
                padding-left: 50%; /* Make space for the label */
            }

            table td:last-child {
                border-bottom: 0; /* No border on the last cell */
            }

            table td::before {
                content: attr(data-label); /* Use data-label for content */
                position: absolute;
                left: 10px;
                width: calc(50% - 20px); /* Adjust width to fit */
                text-align: left;
                font-weight: bold;
                color: var(--spl-text-medium);
                font-size: 0.85em; /* Smaller font for labels */
                white-space: nowrap; /* Prevent label wrapping */
                overflow: hidden;
                text-overflow: ellipsis;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.8em;
            }
            h2 {
                font-size: 1.4em;
            }
            .input-section {
                gap: 10px;
            }
            /* Further reduce font size for very small screens if necessary */
            table td {
                font-size: 0.85em;
            }
            table td::before {
                font-size: 0.8em;
            }
        }

        .instructions {
            background-color: #e9ecef;
            border-left: 5px solid var(--spl-primary-accent);
            padding: 15px 20px;
            margin-top: 20px;
            border-radius: 8px;
            font-size: 0.95em;
            color: var(--spl-text-dark);
            line-height: 1.5;
            width: 100%;
            max-width: 600px; /* Limit width for readability */
            box-sizing: border-box;
            text-align: left; /* Align text left within the instruction box */
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }
        .instructions h3 {
            color: var(--spl-primary-accent);
            margin-top: 0;
            margin-bottom: 10px;
            text-align: left;
            transition: color 0.3s ease; /* Smooth transition */
        }
        .instructions ol {
            margin-left: 20px;
            padding-left: 0;
        }
        .instructions li {
            margin-bottom: 8px;
        }
        .instructions a {
            color: var(--spl-primary-accent);
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease; /* Smooth transition */
        }
        .instructions a:hover {
            text-decoration: underline;
        }

        /* Dark mode specific styles for the instructions box text */
        body.dark-mode .instructions {
            background-color: var(--spl-light-bg); /* Match body background for a unified look */
            border-left-color: var(--spl-primary-accent); /* Keep accent border */
            color: var(--spl-text-dark); /* Ensure main text is light */
        }
        body.dark-mode .instructions h3,
        body.dark-mode .instructions a {
            color: #FFD700; /* Bright gold for heading and links in dark mode */
        }
    </style>
</head>
<body>
    <div id="logo-container">
        <img id="mainLogo" src="unnamed.jpg" alt="Fantasy SPL Data Center Logo">
    </div>

    <!-- Theme Switch -->
    <div class="theme-switch-wrapper">
        <label class="theme-switch" for="darkModeToggle">
            <input type="checkbox" id="darkModeToggle" />
            <span class="slider round"></span>
        </label>
        <em class="theme-label">Dark Mode</em>
    </div>

    <div class="container">
        <h1>Fantasy SPL Manager Analyzer</h1>

        <div class="input-section">
            <label for="managerIdInput">Enter Manager ID:</label>
            <input type="text" id="managerIdInput" placeholder="e.g., 1234" oninput="this.value = convertArabicToWesternNumerals(this.value)">
            <button id="analyzeButton">Full Season Report</button>
            
            <!-- Compatibility Warning Message - Initially hidden -->
            <div id="compatibilityWarning" style="display: none;">
                <strong>Note:</strong> Generating an animated GIF. This format is widely compatible across most devices and platforms.
            </div>

            <!-- Share Video Button - Initially hidden -->
            <button id="shareVideoButton" style="display: none;">Share Report as GIF</button>

            <div id="instructionsBox" class="instructions">
                <h3>How to get your Manager ID:</h3>
                <ol>
                    <li>Go to <a href="https://fantasy.spl.com.sa/" target="_blank">https://fantasy.spl.com.sa/</a> from your browser (SPL app does not work to get your ID).</li>
                    <li>Login with your credentials.</li>
                    <li>Click on "Points" in the top menu.</li>
                    <li>Check the address bar and look for the numbers after the word "/entry/". Copy that - it is your ID number.</li>
                </ol>
            </div>
        </div>

        <div id="loadingMessage" class="loading-message" style="display: none;">
            Loading
        </div>
        <div id="errorMessage" class="error-message" style="display: none;"></div>
        <!-- Video Generating Message - Initially hidden -->
        <div id="videoGeneratingMessage" class="loading-message" style="display: none;">
            Generating GIF... This might take a moment. Please keep this tab open.
        </div>

        <div id="managerStats" style="display: none;">
            <h2 id="managerName"></h2>

            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Overall Rank</h3>
                    <p id="overallRank">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Best Overall Rank</h3>
                    <p id="bestOverallRank">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Worst Overall Rank</h3>
                    <p id="worstOverallRank">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Average Points Per Round</h3>
                    <p id="averagePoints">N/A</p>
                    <p class="small-text">vs. 1st Place Average: <span id="averagePointsFor1stPlace">N/A</span></p>
                </div>
                <div class="stat-card">
                    <h3>Best Round</h3>
                    <p id="bestRoundDisplay">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Worst Round</h3>
                    <p id="worstRoundDisplay">N/A</p>
                </div>
                <!-- Total Green Arrows Card -->
                <div class="stat-card">
                    <h3>Total Green Arrows</h3>
                    <p id="greenArrowsCount">N/A 🟢</p>
                </div>
                <!-- Total Red Arrows Card -->
                <div class="stat-card">
                    <h3>Total Red Arrows</h3>
                    <p id="redArrowsCount">N/A 🔴</p>
                </div>
            </div>

            <!-- Rank Journey Box -->
            <div id="rankJourneyBox" class="rank-journey-box">
                <h3>My Rank Journey</h3>
                <button id="createRankJourneyButton">Click Here</button>
            </div>

            <div class="chart-section" id="rankJourneyChartContainer" style="display: none;">
                <h2>Overall Rank Journey</h2>
                <div id="videoLoadingMessage" class="video-loading-message">
                    Animating rank journey...
                </div>
                <canvas id="rankJourneyChart"></canvas>
            </div>
            
            <!-- Added IDs to table-section divs for easier targeting by html2canvas -->
            <div class="table-section" id="topCaptainsTableContainer">
                <h2>Top 3 Captains</h2>
                <table id="topCaptainsTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Times Captained</th>
                            <th>Success</th>
                            <th>Failed</th>
                            <th>Captained Points</th>
                            <th>Captained Rounds</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <div class="table-section" id="bestPlayersTableContainer">
                <h2>Top 5 Best Players</h2>
                <table id="bestPlayersTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Started</th>
                            <th>Auto Subbed In</th>
                            <th>Points Gained</th>
                            <th>Benched Points</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <div class="table-section" id="worstPlayersTableContainer">
                <h2>Top 5 Worst Players</h2>
                <table id="worstPlayersTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Started</th>
                            <th>Auto Subbed In</th>
                            <th>Points Gained</th>
                            <th>Benched Points</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                    </table>
            </div>

            <div class="table-section" id="missedPointsTableContainer">
                <h2>Top 5 Missed Points (Benched Players)</h2>
                <table id="missedPointsTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Points</th>
                            <th>Round</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <!-- Transfers Summary section - also given an ID -->
            <div class="table-section" id="transfersSummaryContainer">
                <h2>Transfers Summary</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Total Transfers</h3>
                        <p id="totalTransfersCount">N/A</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total Hits (Points Deducted)</h3>
                        <p id="totalHitsPoints">N/A</p>
                    </div>
                </div>
            </div>

            <!-- Most Profitable Transfers Table - given an ID -->
            <div class="table-section" id="profitableTransfersTableContainer">
                <h2>Most Profitable Transfers</h2>
                <table id="profitableTransfersTable">
                    <thead>
                        <tr>
                            <th>IN</th>
                            <th>OUT</th>
                            <th>Round</th>
                            <th>Profit/Loss</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <!-- Most Loss-making Transfers Table - given an ID -->
            <div class="table-section" id="lossMakingTransfersTableContainer">
                <h2>Most Loss-making Transfers</h2>
                <table id="lossMakingTransfersTable">
                    <thead>
                        <tr>
                            <th>IN</th>
                            <th>OUT</th>
                            <th>Round</th>
                            <th>Profit/Loss</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

        </div>
    </div>

    <!-- Hidden canvas for GIF generation - positioned off-screen -->
    <canvas id="gifCaptureCanvas" style="position: absolute; left: -9999px; top: -9999px;"></canvas>

    <script>
        // THIS IS A DEBUGGING LINE - IF YOU SEE THIS, JS IS RUNNING!
        console.log('DEBUG: Script loaded and running!');

        // --- DOM Element References ---
        const managerIdInput = document.getElementById('managerIdInput');
        const analyzeButton = document.getElementById('analyzeButton');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');
        const managerStatsDiv = document.getElementById('managerStats');
        const managerNameElem = document.getElementById('managerName');
        const overallRankElem = document.getElementById('overallRank');
        const bestOverallRankElem = document.getElementById('bestOverallRank');
        const worstOverallRankElem = document.getElementById('worstOverallRank');
        const averagePointsElem = document.getElementById('averagePoints');
        const averagePointsFor1stPlaceElem = document.getElementById('averagePointsFor1stPlace');
        const totalTransfersCountElem = document.getElementById('totalTransfersCount');
        const totalHitsPointsElem = document.getElementById('totalHitsPoints');
        const bestRoundDisplayElem = document.getElementById('bestRoundDisplay');
        const worstRoundDisplayElem = document.getElementById('worstRoundDisplay');
        const greenArrowsCountElem = document.getElementById('greenArrowsCount');
        const redArrowsCountElem = document.getElementById('redArrowsCount');
        
        const topCaptainsTableBody = document.querySelector('#topCaptainsTable tbody');
        const bestPlayersTableBody = document.querySelector('#bestPlayersTable tbody');
        const worstPlayersTableBody = document.querySelector('#worstPlayersTable tbody');
        const missedPointsTableBody = document.querySelector('#missedPointsTable tbody');
        
        const profitableTransfersTableBody = document.querySelector('#profitableTransfersTable tbody');
        const lossMakingTransfersTableBody = document.querySelector('#lossMakingTransfersTable tbody');

        const rankJourneyChartCanvas = document.getElementById('rankJourneyChart');
        const rankJourneyChartContainer = document.getElementById('rankJourneyChartContainer');
        const videoLoadingMessage = document.getElementById('videoLoadingMessage'); // For chart animation loading
        const createRankJourneyButton = document.getElementById('createRankJourneyButton');
        const rankJourneyBox = document.getElementById('rankJourneyBox');
        const instructionsBox = document.getElementById('instructionsBox');

        const darkModeToggle = document.getElementById('darkModeToggle');
        const mainLogo = document.getElementById('mainLogo');

        // NEW: Share Video Button & Video Generating Message & GIF Capture Canvas & Compatibility Warning
        const shareVideoButton = document.getElementById('shareVideoButton');
        const videoGeneratingMessage = document.getElementById('videoGeneratingMessage'); // Reusing this element
        const gifCaptureCanvas = document.getElementById('gifCaptureCanvas'); // Renamed from videoRecordingCanvas
        const compatibilityWarning = document.getElementById('compatibilityWarning');

        const lightModeLogoSrc = 'unnamed.jpg';
        const darkModeLogoSrc = 'dark mode logo.png';

        let rankJourneyChartInstance = null;
        let managerOverallRankHistory = [];
        let managerCurrentOverallRank = null;
        
        // Animation variables for Rank Journey Chart
        const totalAnimationDurationMs = 10000;
        let animationStartTime = null;
        let animationFrameId = null;

        // --- GIF Generation Specific Variables ---
        const gifWidth = 1280; // Standard HD width for GIF frames
        const gifHeight = 720; // Standard HD height for GIF frames
        const sectionFrameDelay = 5000; // 5 seconds in milliseconds for most sections (delay for GIF frames)
        const chartFrameDelay = 10000; // 10 seconds in milliseconds for the chart section (delay for GIF frame)

        // NEW: Global flag to check if data loading and display should have happened
        let dataDisplayAttempted = false;

        // --- Helper Functions ---

        // Function to convert Arabic numerals to Western numerals
        function convertArabicToWesternNumerals(input) {
            const arabicNumerals = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
            const westernNumerals = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
            let convertedInput = input;
            for (let i = 0; i < arabicNumerals.length; i++) {
                const regex = new RegExp(arabicNumerals[i], 'g');
                convertedInput = convertedInput.replace(regex, westernNumerals[i]);
            }
            return convertedInput;
        }

        // Function to set the theme and persist in localStorage
        function setTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                mainLogo.src = darkModeLogoSrc;
                darkModeToggle.checked = true;
            } else {
                document.body.classList.remove('dark-mode');
                mainLogo.src = lightModeLogoSrc;
                darkModeToggle.checked = false;
            }
            localStorage.setItem('theme', theme);
        }

        // --- Event Listeners (UI Interactions) ---

        // Check for saved theme preference on page load
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                setTheme(savedTheme);
            } else {
                setTheme('light'); // Default to light mode if no preference saved
            }
        });

        // Listen for theme toggle changes
        darkModeToggle.addEventListener('change', () => {
            if (darkModeToggle.checked) {
                setTheme('dark');
            } else {
                setTheme('light');
            }
        });

        // Analyze Button click
        analyzeButton.addEventListener('click', () => {
            instructionsBox.style.display = 'none'; // Hide instructions when analysis starts
            compatibilityWarning.style.display = 'none'; // Hide warning on new analysis
            fetchManagerData();
        });

        // Enter key in Manager ID input
        managerIdInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                instructionsBox.style.display = 'none';
                compatibilityWarning.style.display = 'none'; // Hide warning on new analysis
                fetchManagerData();
                managerIdInput.blur(); // Remove focus from input
            }
        });

        // Rank Journey Button click (for chart animation)
        createRankJourneyButton.addEventListener('click', () => {
            rankJourneyChartContainer.style.display = 'flex'; // Show chart container
            createRankJourneyButton.textContent = 'Replay'; // Change button text to Replay

            // Stop any ongoing chart animation before replaying
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationStartTime = null; // Reset start time for a fresh animation
            renderRankJourneyChart(managerOverallRankHistory);
        });

        // NEW: Share Report as GIF Button Click Listener
        shareVideoButton.addEventListener('click', async () => {
            // Disable all interactive buttons during GIF generation
            shareVideoButton.disabled = true;
            analyzeButton.disabled = true;
            createRankJourneyButton.disabled = true;
            darkModeToggle.disabled = true;

            // Show GIF generation loading message
            videoGeneratingMessage.style.display = 'block'; // Reusing this element
            errorMessage.style.display = 'none'; // Hide any previous error messages
            compatibilityWarning.style.display = 'none'; // Hide the warning during generation

            // Ensure the main manager stats are visible before trying to capture them
            managerStatsDiv.style.display = 'block'; 
            
            // Scroll to the top for consistent screenshots starting point (though html2canvas clones now)
            window.scrollTo({ top: 0, behavior: 'instant' });

            // Give browser a moment to settle after layout changes/scroll
            await new Promise(resolve => setTimeout(resolve, 500)); 
            
            try {
                // Initialize and start the GIF generation process
                await generateGIF();
            } catch (error) {
                console.error("Error generating GIF:", error);
                errorMessage.textContent = `Failed to generate GIF: ${error.message}. Please try again.`;
                errorMessage.style.display = 'block';
            } finally {
                // Always re-enable buttons and hide loading message, regardless of success/failure
                shareVideoButton.disabled = false;
                analyzeButton.disabled = false;
                createRankJourneyButton.disabled = false;
                darkModeToggle.disabled = false;
                videoGeneratingMessage.style.display = 'none';
                // Show compatibility warning again if it was previously visible (i.e. if the button itself is block)
                if (shareVideoButton.style.display === 'block') {
                    compatibilityWarning.style.display = 'block';
                }
            }
        });


        // --- Core Data Fetching Logic ---
        async function fetchManagerData() {
            console.log("DEBUG: fetchManagerData started.");
            const managerId = convertArabicToWesternNumerals(managerIdInput.value);
            if (!managerId || !/^\d+$/.test(managerId)) {
                console.warn('DEBUG: Invalid Manager ID entered. Aborting fetch.');
                errorMessage.textContent = 'Please enter a valid Manager ID (numbers only).';
                errorMessage.style.display = 'block';
                // Ensure all relevant sections are hidden on error/invalid input
                managerStatsDiv.style.display = 'none';
                rankJourneyBox.style.display = 'none';
                shareVideoButton.style.display = 'none';
                compatibilityWarning.style.display = 'none'; // Ensure hidden on error
                dataDisplayAttempted = false; // Reset flag
                return;
            }

            loadingMessage.style.display = 'block';
            errorMessage.style.display = 'none';
            managerStatsDiv.style.display = 'none'; // Hide before starting new load
            rankJourneyChartContainer.style.display = 'none';
            videoLoadingMessage.style.display = 'none';
            rankJourneyBox.style.display = 'none';
            createRankJourneyButton.textContent = 'Click Here';
            shareVideoButton.style.display = 'none';
            compatibilityWarning.style.display = 'none'; // Hide on new fetch attempt
            dataDisplayAttempted = false; // Reset flag

            if (rankJourneyChartInstance) {
                console.log('DEBUG: Destroying existing chart instance.');
                rankJourneyChartInstance.destroy();
                rankJourneyChartInstance = null;
            }
            if (animationFrameId) {
                console.log('DEBUG: Cancelling existing chart animation.');
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            animationStartTime = null;

            try {
                console.log(`DEBUG: Attempting to fetch data for manager ID: ${managerId}`);
                const response = await fetch(`/.netlify/functions/fetch-spl-data?id=${managerId}`);
                const data = await response.json();
                console.log('DEBUG: Fetch response received.', { responseOk: response.ok, data: data });

                loadingMessage.style.display = 'none';

                if (response.ok) {
                    dataDisplayAttempted = true; // Set flag
                    console.log('DEBUG: Response OK. Populating manager data...');
                    managerOverallRankHistory = data.overallRankHistory || [];
                    
                    if (data.overallRank && data.overallRank !== 'N/A') {
                        const rankString = String(data.overallRank);
                        managerCurrentOverallRank = Math.round(parseFloat(rankString.replace(/,/g, '')));
                    } else {
                        managerCurrentOverallRank = null; 
                    }

                    managerNameElem.innerHTML = `Team Name: <span style="color: var(--spl-primary-accent);">${data.managerName || `Manager ID: ${managerId}`}</span><br>Rank & Points`;
                    
                    overallRankElem.textContent = `${data.overallRank} 🌏`;
                    
                    let bestRankRaw = String(data.bestOverallRank);
                    let bestRankNumeric = bestRankRaw.split(/\s*\(R|RD\s*\d+\)/i)[0].trim();
                    let bestRankRound = extractAndFormatRound(bestRankRaw);
                    bestOverallRankElem.textContent = `${bestRankNumeric} 🌏 ${bestRankRound}`;

                    let worstRankRaw = String(data.worstOverallRank);
                    let worstRankNumeric = worstRankRaw.split(/\s*\(R|RD\s*\d+\)/i)[0].trim();
                    let worstRankRound = extractAndFormatRound(worstRankRaw);
                    worstOverallRankElem.textContent = `${worstRankNumeric} 🌏 ${worstRankRound}`;

                    averagePointsElem.textContent = data.averagePoints;
                    averagePointsFor1stPlaceElem.textContent = averagePointsFor1stPlaceElem.textContent = data.averagePointsFor1stPlace;
                    
                    const bestRound = data.bestRound;
                    bestRoundDisplayElem.textContent = bestRound.points !== 'N/A' 
                        ? `${bestRound.points} ${bestRound.deductions !== 0 ? `(-${bestRound.deductions})` : ''} Points in Round ${bestRound.round}`
                        : 'N/A';

                    const worstRound = data.worstRound;
                    worstRoundDisplayElem.textContent = worstRound.points !== 'N/A' 
                        ? `${worstRound.points} ${worstRound.deductions !== 0 ? `(-${worstRound.deductions})` : ''} Points in Round ${worstRound.round}`
                        : 'N/A';

                    totalTransfersCountElem.textContent = data.totalTransfersCount;
                    totalHitsPointsElem.textContent = data.totalHitsPoints;
                    
                    greenArrowsCountElem.textContent = `${data.greenArrowsCount || 0} 🟢`;
                    redArrowsCountElem.textContent = `${data.redArrowsCount || 0} 🔴`;
                    
                    rankJourneyBox.style.display = 'flex'; // Show the rank journey button box

                    // Populate tables
                    console.log('DEBUG: Populating topCaptainsTable...');
                    topCaptainsTableBody.innerHTML = '';
                    if (data.top3Captains && data.top3Captains.length > 0) {
                        data.top3Captains.forEach(captain => {
                            const row = topCaptainsTableBody.insertRow();
                            row.insertCell().textContent = captain.name;
                            row.cells[0].setAttribute('data-label', 'Player');
                            row.insertCell().textContent = captain.times;
                            row.cells[1].setAttribute('data-label', 'Times Captained');
                            row.insertCell().textContent = captain.successful;
                            row.cells[2].setAttribute('data-label', 'Success');
                            row.insertCell().textContent = captain.failed;
                            row.cells[3].setAttribute('data-label', 'Failed');
                            row.insertCell().textContent = captain.totalCaptainedPoints;
                            row.cells[4].setAttribute('data-label', 'Captained Points');
                            row.insertCell().textContent = captain.captainedRounds ? captain.captainedRounds.join(', ') : 'N/A';
                            row.cells[5].setAttribute('data-label', 'Captained Rounds');
                        });
                    } else {
                        const row = topCaptainsTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 6;
                    }
                    console.log('DEBUG: Populating bestPlayersTable...');
                    bestPlayersTableBody.innerHTML = '';
                    if (data.bestPlayers && data.bestPlayers.length > 0) {
                        data.bestPlayers.forEach(player => {
                            const row = bestPlayersTableBody.insertRow();
                            row.insertCell().textContent = player.name;
                            row.cells[0].setAttribute('data-label', 'Player');
                            row.insertCell().textContent = player.started;
                            row.cells[1].setAttribute('data-label', 'Started');
                            row.insertCell().textContent = player.autoSubbed;
                            row.cells[2].setAttribute('data-label', 'Auto Subbed In');
                            row.insertCell().textContent = player.pointsGained;
                            row.cells[3].setAttribute('data-label', 'Points Gained');
                            row.insertCell().textContent = player.benchedPoints;
                            row.cells[4].setAttribute('data-label', 'Benched Points');
                        });
                    } else {
                        const row = bestPlayersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 5;
                    }
                    console.log('DEBUG: Populating worstPlayersTable...');
                    worstPlayersTableBody.innerHTML = '';
                    if (data.worstPlayers && data.worstPlayers.length > 0) {
                        data.worstPlayers.forEach(player => {
                            const row = worstPlayersTableBody.insertRow();
                            row.insertCell().textContent = player.name;
                            row.cells[0].setAttribute('data-label', 'Player');
                            row.insertCell().textContent = player.started;
                            row.cells[1].setAttribute('data-label', 'Started');
                            row.insertCell().textContent = player.autoSubbed;
                            row.cells[2].setAttribute('data-label', 'Auto Subbed In');
                            row.insertCell().textContent = player.pointsGained;
                            row.cells[3].setAttribute('data-label', 'Points Gained');
                            row.insertCell().textContent = player.benchedPoints;
                            row.cells[4].setAttribute('data-label', 'Benched Points');
                        });
                    } else {
                        const row = worstPlayersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 5;
                    }
                    console.log('DEBUG: Populating missedPointsTable...');
                    missedPointsTableBody.innerHTML = '';
                    if (data.top5MissedPoints && data.top5MissedPoints.length > 0) {
                        data.top5MissedPoints.forEach(item => {
                            const row = missedPointsTableBody.insertRow();
                            row.insertCell().textContent = item.playerName;
                            row.cells[0].setAttribute('data-label', 'Player');
                            row.insertCell().textContent = item.points;
                            row.cells[1].setAttribute('data-label', 'Points');
                            row.insertCell().textContent = item.round;
                            row.cells[2].setAttribute('data-label', 'Round');
                        });
                    } else {
                        const row = missedPointsTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 3;
                    }
                    console.log('DEBUG: Populating profitableTransfersTable...');
                    profitableTransfersTableBody.innerHTML = '';
                    if (data.top5ProfitableTransfers && data.top5ProfitableTransfers.length > 0) {
                        data.top5ProfitableTransfers.forEach(transfer => {
                            const row = profitableTransfersTableBody.insertRow();
                            row.insertCell().textContent = transfer.playerInName;
                            row.cells[0].setAttribute('data-label', 'IN');
                            row.insertCell().textContent = transfer.playerOutName;
                            row.cells[1].setAttribute('data-label', 'OUT');
                            row.insertCell().textContent = transfer.round;
                            row.cells[2].setAttribute('data-label', 'Round');
                            const profitLossCell = row.insertCell();
                            profitLossCell.textContent = transfer.profitLoss;
                            profitLossCell.classList.add(transfer.profitLoss >= 0 ? 'positive' : 'negative');
                            profitLossCell.setAttribute('data-label', 'Profit/Loss');
                        });
                    } else {
                        const row = profitableTransfersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 4;
                    }
                    console.log('DEBUG: Populating lossMakingTransfersTable...');
                    lossMakingTransfersTableBody.innerHTML = '';
                    if (data.top5LossMakingTransfers && data.top5LossMakingTransfers.length > 0) {
                        data.top5LossMakingTransfers.forEach(transfer => {
                            const row = lossMakingTransfersTableBody.insertRow();
                            row.insertCell().textContent = transfer.playerInName;
                            row.cells[0].setAttribute('data-label', 'IN');
                            row.insertCell().textContent = transfer.playerOutName;
                            row.cells[1].setAttribute('data-label', 'OUT');
                            row.insertCell().textContent = transfer.round;
                            row.cells[2].setAttribute('data-label', 'Round');
                            const profitLossCell = row.insertCell();
                            profitLossCell.textContent = transfer.profitLoss;
                            profitLossCell.classList.add(transfer.profitLoss >= 0 ? 'positive' : 'negative');
                            profitLossCell.setAttribute('data-label', 'Profit/Loss');
                        });
                    } else {
                        const row = lossMakingTransfersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 4;
                    }

                    // Set display to block
                    managerStatsDiv.style.display = 'block'; 
                    rankJourneyChartContainer.style.display = 'none'; 
                    shareVideoButton.style.display = 'block';
                    compatibilityWarning.style.display = 'block'; // Show warning on successful data load

                    console.log('DEBUG: managerStatsDiv display style AFTER JS set:', managerStatsDiv.style.display);
                    console.log('DEBUG: managerStatsDiv computed display style AFTER JS set:', getComputedStyle(managerStatsDiv).display);
                    console.log('DEBUG: managerStatsDiv innerHTML length:', managerStatsDiv.innerHTML.length);
                    console.log('DEBUG: managerStatsDiv clientHeight:', managerStatsDiv.clientHeight);
                    console.log('DEBUG: managerStatsDiv offsetHeight:', managerStatsDiv.offsetHeight);
                    console.log('DEBUG: managerStatsDiv getBoundingClientRect:', managerStatsDiv.getBoundingClientRect());

                } else {
                    console.error('DEBUG: API response not OK:', data.error || 'Unknown error');
                    errorMessage.textContent = data.error || 'An unknown error occurred.';
                    errorMessage.style.display = 'block';
                    // Hide all relevant sections on error
                    managerStatsDiv.style.display = 'none';
                    rankJourneyBox.style.display = 'none';
                    shareVideoButton.style.display = 'none';
                    compatibilityWarning.style.display = 'none'; // Hide on error
                }

            } catch (error) {
                console.error("DEBUG: Critical fetchManagerData error (outer catch):", error);
                errorMessage.textContent = `Failed to fetch data: ${error.message}. This might be due to a network issue, an invalid Manager ID, or a temporary API problem. Please try again.`;
                errorMessage.style.display = 'block';
                loadingMessage.style.display = 'none'; // Ensure loading message is hidden
                // Hide all relevant sections on error
                managerStatsDiv.style.display = 'none';
                rankJourneyBox.style.display = 'none';
                shareVideoButton.style.display = 'none';
                compatibilityWarning.style.display = 'none';
            }
            console.log("DEBUG: fetchManagerData finished.");
        }

        // --- Chart Rendering Logic (Existing) ---
        function extractAndFormatRound(rankValueString) {
            if (typeof rankValueString !== 'string' || rankValueString === 'N/A') {
                return '';
            }
            const match = rankValueString.match(/\((R|RD)\s*(\d+)\)/i);
            if (match && match[2]) {
                return `(In Round ${match[2]})`;
            }
            return '';
        }

        function renderRankJourneyChart(fullRankHistoryData) {
            if (!fullRankHistoryData || fullRankHistoryData.length === 0) {
                console.warn("DEBUG: No rank data to render chart.");
                return;
            }

            fullRankHistoryData.sort((a, b) => a.round - b.round);

            const fixedMaxRound = 34; 
            const labels = Array.from({ length: fixedMaxRound + 1 }, (_, i) => `Round ${i}`);
            
            const ranks = Array(fixedMaxRound + 1).fill(null);
            fullRankHistoryData.forEach(d => {
                if (d.round >= 1 && d.round <= fixedMaxRound) {
                    ranks[d.round] = d.rank;
                }
            });

            const validRanksForScaling = ranks.filter(rank => typeof rank === 'number' && !isNaN(rank));
            const minRankInHistory = validRanksForScaling.length > 0 ? Math.min(...validRanksForScaling) : 1;
            const maxRankInHistory = validRanksForScaling.length > 0 ? Math.max(...validRanksForScaling) : 114154;

            let overallYAxisMax;
            const decisionRank = managerCurrentOverallRank !== null ? managerCurrentOverallRank : maxRankInHistory;

            if (decisionRank >= 1 && decisionRank <= 100) {
                overallYAxisMax = maxRankInHistory + 10;
            } else if (decisionRank > 100 && decisionRank <= 3000) {
                overallYAxisMax = maxRankInHistory + 50;
            } else if (decisionRank > 3000) {
                overallYAxisMax = maxRankInHistory + 200;
            } else {
                overallYAxisMax = maxRankInHistory + 100;
            }

            overallYAxisMax = Math.min(Math.max(overallYAxisMax, minRankInHistory + 10, 200), 114154); 

            console.log(`DEBUG: Chart Y-axis Debug: Min Rank (History): ${minRankInHistory}, Max Rank (History): ${maxRankInHistory}, Current Overall Rank (for decision): ${decisionRank}, Calculated Y-axis Max: ${overallYAxisMax}`);

            videoLoadingMessage.style.display = 'block';

            const ctx = rankJourneyChartCanvas.getContext('2d');
            if (rankJourneyChartInstance) {
                rankJourneyChartInstance.destroy();
            }

            const isMobile = window.innerWidth <= 950;

            rankJourneyChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Overall Rank',
                            data: [],
                            tension: 0.1,
                            spanGaps: true,
                            pointRadius: 0,
                            borderColor: (context) => {
                                const currentPoint = context.dataset.data[context.dataIndex];
                                const previousPoint = context.dataset.data[context.dataIndex - 1];
                                
                                if (!currentPoint || !previousPoint || typeof currentPoint.y !== 'number' || typeof previousPoint.y !== 'number') {
                                    return '#007BFF';
                                }
                                if (currentPoint.y < previousPoint.y) {
                                    return '#28A745';
                                } else if (currentPoint.y > previousPoint.y) {
                                    return '#DC3545';
                                } else {
                                    return '#495057';
                                }
                            },
                            backgroundColor: 'rgba(0, 0, 0, 0)',
                            fill: false,
                            xAxisID: 'x-linear',
                            yAxisID: 'y-rank'
                        },
                        {
                            label: 'Current Rank',
                            data: [],
                            pointRadius: 8,
                            pointBackgroundColor: 'red',
                            pointBorderColor: 'white',
                            pointBorderWidth: 2,
                            showLine: false,
                            type: 'scatter',
                            xAxisID: 'x-linear',
                            yAxisID: 'y-rank',
                            hidden: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: isMobile ? 1.5 : 2,
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: 'var(--spl-text-dark)', 
                                filter: function(legendItem, chartData) {
                                    return legendItem.text === 'Overall Rank';
                                }
                            }
                        }
                    },
                    scales: {
                        'x-linear': {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Round',
                                color: 'var(--spl-text-dark)'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            min: 0,
                            max: fixedMaxRound,
                            ticks: {
                                color: 'var(--spl-text-dark)',
                                autoSkip: false,
                                maxRotation: 0,
                                minRotation: 0,
                                values: [0, 4, 8, 12, 16, 20, 24, 28, 32, 34],
                                callback: function(value, index) {
                                    return labels[value].replace('Round ', '');
                                },
                                font: {
                                    size: isMobile ? 9 : 12
                                }
                            }
                        },
                        'y-rank': {
                            type: 'linear',
                            display: true,
                            title: {
                                display: !isMobile,
                                text: 'Overall Rank (Lower is Better)',
                                color: 'var(--spl-text-dark)'
                            },
                            reverse: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            min: 1,
                            max: overallYAxisMax,
                            ticks: {
                                color: 'var(--spl-text-dark)',
                                callback: function(value, index, values) {
                                    return new Intl.NumberFormat().format(value);
                                },
                                maxTicksLimit: isMobile ? 20 : 10,
                                font: {
                                    size: isMobile ? 9 : 12
                                }
                            }
                        }
                    }
                }
            });

            function animateChart(timestamp) {
                if (!animationStartTime) {
                    animationStartTime = timestamp;
                }

                const elapsedTime = timestamp - animationStartTime;
                const progress = Math.min(elapsedTime / totalAnimationDurationMs, 1);

                const firstDataRound = fullRankHistoryData.length > 0 ? fullRankHistoryData[0].round : 0;
                const lastDataRound = fullRankHistoryData.length > 0 ? fullRankHistoryData[fullRankHistoryData.length - 1].round : fixedMaxRound;
                const dataRoundRange = lastDataRound - firstDataRound;

                let currentRoundForDot = firstDataRound + (progress * dataRoundRange);
                currentRoundForDot = Math.min(currentRoundForDot, lastDataRound);

                let interpolatedRank = null;
                let dotXPosition = currentRoundForDot;

                let prevDataPoint = null;
                let nextDataPoint = null;

                for (let i = 0; i < fullRankHistoryData.length; i++) {
                    if (fullRankHistoryData[i].round <= currentRoundForDot) {
                        prevDataPoint = fullRankHistoryData[i];
                    } else {
                        nextDataPoint = fullRankHistoryData[i];
                        break;
                    }
                }

                if (prevDataPoint && nextDataPoint) {
                    const roundRange = nextDataPoint.round - prevDataPoint.round;
                    const rankRange = nextDataPoint.rank - prevDataPoint.rank;
                    const factor = (currentRoundForDot - prevDataPoint.round) / roundRange;
                    interpolatedRank = prevDataPoint.rank + (rankRange * factor);
                } else if (prevDataPoint) {
                    interpolatedRank = prevDataPoint.rank;
                } else {
                    interpolatedRank = null; 
                }
                
                if (interpolatedRank !== null) {
                    rankJourneyChartInstance.data.datasets[1].data = [{ x: dotXPosition, y: interpolatedRank }];
                } else {
                    rankJourneyChartInstance.data.datasets[1].data = [];
                }

                const traceData = [];
                for (let i = 0; i < fullRankHistoryData.length; i++) {
                    if (fullRankHistoryData[i].round <= currentRoundForDot) {
                        traceData.push({ x: fullRankHistoryData[i].round, y: fullRankHistoryData[i].rank });
                    } else {
                        break;
                    }
                }
                if (interpolatedRank !== null && traceData.length > 0 && dotXPosition > traceData[traceData.length - 1].x) {
                    traceData.push({ x: dotXPosition, y: interpolatedRank });
                } else if (interpolatedRank !== null && traceData.length === 0 && fullRankHistoryData.length > 0 && dotXPosition >= fullRankHistoryData[0].round) {
                    traceData.push({ x: dotXPosition, y: interpolatedRank });
                }
                
                rankJourneyChartInstance.data.datasets[0].data = traceData;

                rankJourneyChartInstance.update();

                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animateChart);
                } else {
                    videoLoadingMessage.style.display = 'none';
                    rankJourneyChartInstance.data.datasets[0].data = fullRankHistoryData.map(d => ({ x: d.round, y: d.rank }));
                    rankJourneyChartInstance.data.datasets[0].pointRadius = 3; 
                    
                    const lastDataPoint = fullRankHistoryData[fullRankHistoryData.length - 1];
                    if (lastDataPoint) {
                        rankJourneyChartInstance.data.datasets[1].data = [{ x: lastDataPoint.round, y: lastDataPoint.rank }];
                    } else {
                        rankJourneyChartInstance.data.datasets[1].data = [];
                    }
                    rankJourneyChartInstance.update();
                    animationStartTime = null;
                    animationFrameId = null;
                }
            }

            animationFrameId = requestAnimationFrame(animateChart);
        }

        // --- NEW: GIF Generation Logic ---

        /**
         * Captures specified sections as high-resolution canvases using html2canvas.
         * Temporarily makes elements visible in the cloned DOM for accurate capture.
         * @returns {Promise<Array<Object>>} An array of objects, each containing a canvas and its display duration.
         */
        async function captureAndPrepareSectionsForGIF() {
            console.log("DEBUG: Starting captureAndPrepareSectionsForGIF...");
            // Define the sections to capture and their durations
            const sectionsToCaptureConfig = [
                { id: 'managerStats', duration: sectionFrameDelay, display: 'block' },
                { id: 'rankJourneyChartContainer', duration: chartFrameDelay, display: 'flex' }, 
                { id: 'topCaptainsTableContainer', duration: sectionFrameDelay, display: 'block' },
                { id: 'bestPlayersTableContainer', duration: sectionFrameDelay, display: 'block' },
                { id: 'worstPlayersTableContainer', duration: sectionFrameDelay, display: 'block' },
                { id: 'missedPointsTableContainer', duration: sectionFrameDelay, display: 'block' },
                { id: 'transfersSummaryContainer', duration: sectionFrameDelay, display: 'block' },
                { id: 'profitableTransfersTableContainer', duration: sectionFrameDelay, display: 'block' },
                { id: 'lossMakingTransfersTableContainer', duration: sectionFrameDelay, display: 'block' },
            ];

            const capturedCanvases = [];

            // Ensure the chart's animation is reset to its final state before capturing for GIF
            if (rankJourneyChartInstance) {
                console.log('DEBUG: Resetting chart animation for GIF capture.');
                rankJourneyChartInstance.data.datasets[0].data = managerOverallRankHistory.map(d => ({ x: d.round, y: d.rank }));
                rankJourneyChartInstance.data.datasets[0].pointRadius = 3; 
                const lastDataPoint = managerOverallRankHistory[managerOverallRankHistory.length - 1];
                if (lastDataPoint) {
                    rankJourneyChartInstance.data.datasets[1].data = [{ x: lastDataPoint.round, y: lastDataPoint.rank }];
                } else {
                    rankJourneyChartInstance.data.datasets[1].data = [];
                }
                rankJourneyChartInstance.update();
                await new Promise(resolve => setTimeout(resolve, 100)); // Give chart time to render
            }

            // Temporarily make the main stats container visible if it's hidden, for full capture
            const originalManagerStatsDisplay = managerStatsDiv.style.display;
            managerStatsDiv.style.display = 'block'; // Set to block, without !important
            await new Promise(resolve => setTimeout(resolve, 50)); // Allow layout to settle

            for (const sectionConfig of sectionsToCaptureConfig) {
                const element = document.getElementById(sectionConfig.id);
                if (element) {
                    console.log(`DEBUG: Capturing section for GIF: ${sectionConfig.id}`);
                    try {
                        const canvas = await html2canvas(element, {
                            useCORS: true, 
                            scale: 2, // High resolution capture
                            backgroundColor: null, // Let html2canvas use element's background
                            allowTaint: true, 
                            ignoreElements: (el) => {
                                return el.id === 'shareVideoButton' || 
                                       el.id === 'videoGeneratingMessage' || 
                                       el.id === 'compatibilityWarning' ||
                                       el.classList.contains('theme-switch-wrapper') ||
                                       el.id === 'gifCaptureCanvas';
                            },
                            onclone: (clonedDoc) => {
                                // Apply the current theme to the cloned document
                                if (document.body.classList.contains('dark-mode')) {
                                    clonedDoc.body.classList.add('dark-mode');
                                }
                                // Ensure the main logo in cloned doc reflects the current theme
                                const clonedMainLogo = clonedDoc.getElementById('mainLogo');
                                if (clonedMainLogo) {
                                    clonedMainLogo.src = mainLogo.src; // Copy current src
                                }
                                
                                // Make ALL content sections visible in the cloned DOM for capture
                                // Use setProperty for consistency, but no !important unless truly needed
                                clonedDoc.getElementById('managerStats').style.display = 'block';
                                clonedDoc.getElementById('rankJourneyChartContainer').style.display = 'flex';
                                clonedDoc.getElementById('topCaptainsTableContainer').style.display = 'block';
                                clonedDoc.getElementById('bestPlayersTableContainer').style.display = 'block';
                                clonedDoc.getElementById('worstPlayersTableContainer').style.display = 'block';
                                clonedDoc.getElementById('missedPointsTableContainer').style.display = 'block';
                                clonedDoc.getElementById('transfersSummaryContainer').style.display = 'block';
                                clonedDoc.getElementById('profitableTransfersTableContainer').style.display = 'block';
                                clonedDoc.getElementById('lossMakingTransfersTableContainer').style.display = 'block';

                                // Adjust cloned body styles to fit content without scrolling
                                clonedDoc.body.style.overflow = 'visible';
                                clonedDoc.body.style.height = 'auto';

                                // Specific fix for Chart.js canvas in cloned DOM
                                const clonedChartCanvas = clonedDoc.getElementById('rankJourneyChart');
                                if (clonedChartCanvas) {
                                    // Ensure chart is not displaying 'Animating rank journey...' text in clone
                                    const clonedVideoLoadingMessage = clonedDoc.getElementById('videoLoadingMessage');
                                    if (clonedVideoLoadingMessage) {
                                        clonedVideoLoadingMessage.style.display = 'none';
                                    }
                                }
                            }
                        });
                        capturedCanvases.push({
                            canvas: canvas,
                            delay: sectionConfig.duration // Delay for this frame in the GIF
                        });
                        console.log(`DEBUG: Successfully captured ${sectionConfig.id} for GIF.`);
                    } catch (e) {
                        console.error(`ERROR: Failed to capture section ${sectionConfig.id} for GIF:`, e);
                        // Push a blank/error image if capture fails
                        const errorCanvas = document.createElement('canvas');
                        errorCanvas.width = gifWidth; errorCanvas.height = gifHeight;
                        const errorCtx = errorCanvas.getContext('2d');
                        errorCtx.fillStyle = '#333';
                        errorCtx.fillRect(0, 0, gifWidth, gifHeight);
                        errorCtx.fillStyle = 'white';
                        errorCtx.font = '24px Arial';
                        errorCtx.textAlign = 'center';
                        errorCtx.textBaseline = 'middle';
                        errorCtx.fillText(`Capture failed: ${sectionConfig.id}`, gifWidth / 2, gifHeight / 2);
                        capturedCanvases.push({
                            canvas: errorCanvas,
                            delay: sectionConfig.duration
                        });
                    }
                } else {
                    console.warn(`DEBUG: Element with ID ${sectionConfig.id} not found, skipping capture for GIF.`);
                }
            }
            
            // Restore original manager stats display state
            managerStatsDiv.style.display = originalManagerStatsDisplay;
            console.log("DEBUG: Finished captureAndPrepareSectionsForGIF.");
            return capturedCanvases;
        }

        /**
         * Generates an animated GIF from captured section canvases.
         */
        async function generateGIF() {
            console.log("DEBUG: Starting GIF generation process...");
            const sections = await captureAndPrepareSectionsForGIF();

            if (sections.length === 0) {
                throw new Error("No sections captured for GIF generation.");
            }

            const gif = new GIF({
                workers: 2, // Use 2 web workers for faster processing
                quality: 10, // Adjust quality (lower is faster but more lossy)
                width: gifWidth,
                height: gifHeight,
                transparent: 'rgba(0,0,0,0)', // Ensure transparency is handled
                background: getComputedStyle(document.body).backgroundColor, // Set background from current theme
                // IMPORTANT: Point to the locally hosted worker script
                workerScript: './gif.worker.js' 
            });

            // Add each captured canvas as a frame with its specific delay
            sections.forEach(section => {
                gif.addFrame(section.canvas, { delay: section.delay });
            });

            gif.on('start', function() {
                console.log("DEBUG: GIF generation started...");
            });

            gif.on('progress', function(p) {
                console.log('DEBUG: GIF generation progress: ' + Math.round(p * 100) + '%');
                videoGeneratingMessage.textContent = `Generating GIF... ${Math.round(p * 100)}% complete.`;
            });

            gif.on('finished', function(blob) {
                console.log('DEBUG: GIF generation finished! Size:', blob.size, 'bytes');
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `spl_report_${Date.now()}.gif`; // Suggested filename for GIF
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                console.log("DEBUG: GIF download triggered.");
                videoGeneratingMessage.textContent = 'GIF generated and download started!';
                // Re-enable buttons immediately after download starts
                shareVideoButton.disabled = false;
                analyzeButton.disabled = false;
                createRankJourneyButton.disabled = false;
                darkModeToggle.disabled = false;
                compatibilityWarning.style.display = 'block'; // Re-show warning after completion
            });

            gif.on('error', function(error) {
                console.error("DEBUG: GIF generation error:", error);
                errorMessage.textContent = `GIF generation failed: ${error.message}. Please try again.`;
                errorMessage.style.display = 'block';
                videoGeneratingMessage.style.display = 'none'; // Hide loading message
            });

            gif.render(); // Start the GIF rendering process
        }
    </script>
</body>
</html>