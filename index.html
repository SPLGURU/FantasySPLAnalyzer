<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy SPL Manager Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Oswald:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* SPL Fantasy Inspired Design - LIGHT MODE */
        :root {
            /* Main Colors - Adjusted for a lighter theme and better table contrast */
            --spl-light-bg: #F8F9FA; /* Very light background for body */
            --spl-container-bg: #FFFFFF; /* White for main container/cards */
            --spl-table-bg: #E0E4E8; /* Distinct light grey for table background */
            --spl-table-header-bg: #B3D9FF; /* Light blue for table headers */
            --spl-table-row-even: #D6DBE0; /* Slightly different shade for even rows */
            --spl-table-row-hover: #C7CCD1; /* Lighter grey for hover */

            --spl-text-dark: #212529; /* Dark text for primary content */
            --spl-text-medium: #495057; /* Medium dark grey for secondary text */
            --spl-accent-blue: #007BFF; /* Primary accent blue */
            --spl-accent-green: #28A745; /* Green for positive indicators */
            --spl-accent-red: #DC3545; /* Red for negative indicators */
            --spl-border-light: #CED4DA; /* Light border for elements */
            --spl-shadow: rgba(0, 0, 0, 0.1); /* Subtle shadow */
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--spl-light-bg);
            color: var(--spl-text-dark);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            box-shadow: 0 6px 12px var(--spl-shadow);
            padding: 30px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
        }

        h1, h2, h3 {
            font-family: 'Oswald', sans-serif;
            color: var(--spl-accent-blue);
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .input-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .input-section label {
            font-weight: bold;
            color: var(--spl-text-medium);
            font-size: 1.1em;
        }

        .input-section input[type="number"] {
            padding: 12px 15px;
            border: 1px solid var(--spl-border-light);
            border-radius: 8px;
            font-size: 1em;
            width: 100%;
            max-width: 300px;
            box-sizing: border-box;
            text-align: center;
        }

        .input-section button {
            background-color: var(--spl-accent-blue);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
        }

        .input-section button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }

        .loading-message, .error-message, .video-loading-message {
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: bold;
        }

        .loading-message {
            background-color: #e0f7fa;
            color: #007BFF;
        }

        .error-message {
            background-color: #ffe0e6;
            color: #DC3545;
            border: 1px solid #DC3545;
        }

        .video-loading-message {
            background-color: #fff3cd;
            color: #856404;
            display: none; /* Hidden by default */
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .stat-card {
            background-color: var(--spl-table-bg); /* Use a slightly darker background for cards */
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
            text-align: center;
            transition: transform 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-3px);
        }

        .stat-card h3 {
            color: var(--spl-accent-blue);
            margin-top: 0;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .stat-card p {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--spl-text-dark);
            margin: 0;
        }

        .stat-card .small-text {
            font-size: 0.9em;
            color: var(--spl-text-medium);
            margin-top: 5px;
        }

        .chart-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            box-shadow: 0 6px 12px var(--spl-shadow);
            /* Centering the chart within its section */
            display: flex;
            flex-direction: column;
            align-items: center; /* Center horizontally */
        }

        .chart-section h2 {
            margin-bottom: 20px;
        }

        #rankJourneyChart {
            width: 100%; /* Take full width of its container */
            max-width: 900px; /* Limit max width on large screens */
            height: auto; /* Height will be controlled by aspect ratio in JS */
            box-sizing: border-box;
        }

        .table-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            box-shadow: 0 6px 12px var(--spl-shadow);
            /* Removed overflow-x: auto; for mobile optimization */
        }

        .table-section h2 {
            margin-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            /* Removed min-width: 600px; for mobile optimization */
            table-layout: fixed; /* Ensures columns respect defined widths */
        }

        th, td {
            padding: 12px 15px;
            border: 1px solid var(--spl-border-light);
            text-align: left;
            word-break: break-word; /* Allow long words to break */
            white-space: normal; /* Ensure text wraps */
        }

        th {
            background-color: var(--spl-table-header-bg);
            color: var(--spl-text-dark);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        tr:nth-child(even) {
            background-color: var(--spl-table-row-even);
        }

        tr:hover {
            background-color: var(--spl-table-row-hover);
        }

        .positive {
            color: var(--spl-accent-green);
            font-weight: bold;
        }

        .negative {
            color: var(--spl-accent-red);
            font-weight: bold;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .container {
                padding: 20px;
            }

            .input-section input[type="number"],
            .input-section button {
                font-size: 0.95em;
                padding: 10px 20px;
            }

            .stats-grid {
                grid-template-columns: 1fr; /* Stack cards on small screens */
            }

            .stat-card p {
                font-size: 1.5em;
            }

            /* Tables specific adjustments for mobile */
            th, td {
                padding: 8px 10px;
                font-size: 0.75em; /* Smaller font size for all table cells */
            }

            /* Top 3 Captains Table */
            #topCaptainsTable th:nth-child(1), #topCaptainsTable td:nth-child(1) { width: 25%; } /* Player */
            #topCaptainsTable th:nth-child(2), #topCaptainsTable td:nth-child(2) { width: 15%; } /* Times Captained */
            #topCaptainsTable th:nth-child(3), #topCaptainsTable td:nth-child(3) { width: 10%; } /* Success */
            #topCaptainsTable th:nth-child(4), #topCaptainsTable td:nth-child(4) { width: 10%; } /* Failed */
            #topCaptainsTable th:nth-child(5), #topCaptainsTable td:nth-child(5) { width: 20%; } /* Captained Points */
            #topCaptainsTable th:nth-child(6), #topCaptainsTable td:nth-child(6) { width: 20%; } /* Captained Rounds */

            /* Top 5 Best/Worst Players Tables */
            #bestPlayersTable th:nth-child(1), #bestPlayersTable td:nth-child(1),
            #worstPlayersTable th:nth-child(1), #worstPlayersTable td:nth-child(1) { width: 25%; } /* Player */
            #bestPlayersTable th:nth-child(2), #bestPlayersTable td:nth-child(2),
            #worstPlayersTable th:nth-child(2), #worstPlayersTable td:nth-child(2) { width: 15%; } /* Started */
            #bestPlayersTable th:nth-child(3), #bestPlayersTable td:nth-child(3),
            #worstPlayersTable th:nth-child(3), #worstPlayersTable td:nth-child(3) { width: 20%; } /* Auto Subbed In */
            #bestPlayersTable th:nth-child(4), #bestPlayersTable td:nth-child(4),
            #worstPlayersTable th:nth-child(4), #worstPlayersTable td:nth-child(4) { width: 20%; } /* Points Gained */
            #bestPlayersTable th:nth-child(5), #bestPlayersTable td:nth-child(5),
            #worstPlayersTable th:nth-child(5), #worstPlayersTable td:nth-child(5) { width: 20%; } /* Benched Points */

            /* Top 5 Missed Points Table */
            #missedPointsTable th:nth-child(1), #missedPointsTable td:nth-child(1) { width: 40%; } /* Player */
            #missedPointsTable th:nth-child(2), #missedPointsTable td:nth-child(2) { width: 30%; } /* Points */
            #missedPointsTable th:nth-child(3), #missedPointsTable td:nth-child(3) { width: 30%; } /* Round */

            /* Profitable/Loss-making Transfers Tables */
            #profitableTransfersTable th:nth-child(1), #profitableTransfersTable td:nth-child(1),
            #lossMakingTransfersTable th:nth-child(1), #lossMakingTransfersTable td:nth-child(1) { width: 25%; } /* IN */
            #profitableTransfersTable th:nth-child(2), #profitableTransfersTable td:nth-child(2),
            #lossMakingTransfersTable th:nth-child(2), #lossMakingTransfersTable td:nth-child(2) { width: 25%; } /* OUT */
            #profitableTransfersTable th:nth-child(3), #profitableTransfersTable td:nth-child(3),
            #lossMakingTransfersTable th:nth-child(3), #lossMakingTransfersTable td:nth-child(3) { width: 20%; } /* Round */
            #profitableTransfersTable th:nth-child(4), #profitableTransfersTable td:nth-child(4),
            #lossMakingTransfersTable th:nth-child(4), #lossMakingTransfersTable td:nth-child(4) { width: 30%; } /* Profit/Loss */
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.8em;
            }
            h2 {
                font-size: 1.4em;
            }
            .input-section {
                gap: 10px;
            }
            th, td {
                font-size: 0.65em; /* Even smaller font size for very small screens */
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Fantasy SPL Manager Analyzer</h1>

        <div class="input-section">
            <label for="managerIdInput">Enter Manager ID:</label>
            <input type="number" id="managerIdInput" placeholder="e.g., 4">
            <button id="analyzeButton">Analyze Manager</button>
        </div>

        <div id="loadingMessage" class="loading-message" style="display: none;">
            Loading
        </div>
        <div id="errorMessage" class="error-message" style="display: none;"></div>

        <div id="managerStats" style="display: none;">
            <h2 id="managerName"></h2>

            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Overall Rank</h3>
                    <p id="overallRank">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Best Overall Rank</h3>
                    <p id="bestOverallRank">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Worst Overall Rank</h3>
                    <p id="worstOverallRank">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Average Points Per Round</h3>
                    <p id="averagePoints">N/A</p>
                    <p class="small-text">vs. 1st Place Average: <span id="averagePointsFor1stPlace">N/A</span></p>
                </div>
                <div class="stat-card">
                    <h3>Total Transfers</h3>
                    <p id="totalTransfersCount">N/A</p>
                </div>
                <div class="stat-card">
                    <h3>Total Hits (Points Deducted)</h3>
                    <p id="totalHitsPoints">N/A</p>
                </div>
                <!-- Removed: Non-Active Manager Status card -->
            </div>

            <div class="chart-section">
                <h2>Overall Rank Journey</h2>
                <div id="videoLoadingMessage" class="video-loading-message">
                    Animating rank journey...
                </div>
                <canvas id="rankJourneyChart"></canvas>
            </div>

            <div class="table-section">
                <h2>Top 3 Captains</h2>
                <table id="topCaptainsTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Times Captained</th>
                            <th>Success</th>
                            <th>Failed</th>
                            <th>Captained Points</th>
                            <th>Captained Rounds</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <div class="table-section">
                <h2>Top 5 Best Players</h2>
                <table id="bestPlayersTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Started</th>
                            <th>Auto Subbed In</th>
                            <th>Points Gained</th>
                            <th>Benched Points</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <div class="table-section">
                <h2>Top 5 Worst Players</h2>
                <table id="worstPlayersTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Started</th>
                            <th>Auto Subbed In</th>
                            <th>Points Gained</th>
                            <th>Benched Points</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                    </table>
            </div>

            <div class="table-section">
                <h2>Top 5 Missed Points (Benched Players)</h2>
                <table id="missedPointsTable">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Points</th>
                            <th>Round</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <!-- NEW: Most Profitable Transfers Table -->
            <div class="table-section">
                <h2>Most Profitable Transfers</h2>
                <table id="profitableTransfersTable">
                    <thead>
                        <tr>
                            <th>IN</th>
                            <th>OUT</th>
                            <th>Round</th>
                            <th>Profit/Loss</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

            <!-- NEW: Most Loss-making Transfers Table -->
            <div class="table-section">
                <h2>Most Loss-making Transfers</h2>
                <table id="lossMakingTransfersTable">
                    <thead>
                        <tr>
                            <th>IN</th>
                            <th>OUT</th>
                            <th>Round</th>
                            <th>Profit/Loss</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>

        </div>
    </div>

    <script>
        const managerIdInput = document.getElementById('managerIdInput');
        const analyzeButton = document.getElementById('analyzeButton');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');
        const managerStatsDiv = document.getElementById('managerStats');
        const managerNameElem = document.getElementById('managerName');
        const overallRankElem = document.getElementById('overallRank');
        const bestOverallRankElem = document.getElementById('bestOverallRank');
        const worstOverallRankElem = document.getElementById('worstOverallRank');
        const averagePointsElem = document.getElementById('averagePoints');
        const averagePointsFor1stPlaceElem = document.getElementById('averagePointsFor1stPlace');
        const totalTransfersCountElem = document.getElementById('totalTransfersCount');
        const totalHitsPointsElem = document.getElementById('totalHitsPoints');
        // Removed: nonActiveManagerStatusElem declaration

        const topCaptainsTableBody = document.querySelector('#topCaptainsTable tbody');
        const bestPlayersTableBody = document.querySelector('#bestPlayersTable tbody');
        const worstPlayersTableBody = document.querySelector('#worstPlayersTable tbody');
        const missedPointsTableBody = document.querySelector('#missedPointsTable tbody');
        
        // Table bodies for transfers
        const profitableTransfersTableBody = document.querySelector('#profitableTransfersTable tbody');
        const lossMakingTransfersTableBody = document.querySelector('#lossMakingTransfersTable tbody');

        const rankJourneyChartCanvas = document.getElementById('rankJourneyChart');
        const videoLoadingMessage = document.getElementById('videoLoadingMessage');
        let rankJourneyChartInstance = null; // To store the Chart.js instance

        analyzeButton.addEventListener('click', fetchManagerData);

        // Removed: Pre-fill with manager ID 4 for convenience
        // managerIdInput.value = 4; // This line is removed

        async function fetchManagerData() {
            const managerId = managerIdInput.value;
            if (!managerId) {
                errorMessage.textContent = 'Please enter a Manager ID.';
                errorMessage.style.display = 'block';
                managerStatsDiv.style.display = 'none';
                return;
            }

            loadingMessage.style.display = 'block';
            errorMessage.style.display = 'none';
            managerStatsDiv.style.display = 'none';
            videoLoadingMessage.style.display = 'none'; // Hide video loading message initially

            // Destroy previous chart instance if it exists
            if (rankJourneyChartInstance) {
                rankJourneyChartInstance.destroy();
                rankJourneyChartInstance = null;
            }

            try {
                const response = await fetch(`/.netlify/functions/fetch-spl-data?id=${managerId}`);
                const data = await response.json();

                loadingMessage.style.display = 'none';

                if (response.ok) {
                    managerNameElem.textContent = data.managerName || `Manager ID: ${managerId}`; // Assuming managerName is returned
                    overallRankElem.textContent = data.overallRank;
                    bestOverallRankElem.textContent = data.bestOverallRank;
                    worstOverallRankElem.textContent = data.worstOverallRank;
                    averagePointsElem.textContent = data.averagePoints;
                    averagePointsFor1stPlaceElem.textContent = data.averagePointsFor1stPlace;
                    totalTransfersCountElem.textContent = data.totalTransfersCount;
                    totalHitsPointsElem.textContent = data.totalHitsPoints;
                    
                    // Removed: Non-Active Manager Status display logic from here


                    // Populate Top 3 Captains Table
                    topCaptainsTableBody.innerHTML = '';
                    if (data.top3Captains && data.top3Captains.length > 0) {
                        data.top3Captains.forEach(captain => {
                            const row = topCaptainsTableBody.insertRow();
                            row.insertCell().textContent = captain.name;
                            row.insertCell().textContent = captain.times;
                            row.insertCell().textContent = captain.successful;
                            row.insertCell().textContent = captain.failed;
                            row.insertCell().textContent = captain.totalCaptainedPoints;
                            row.insertCell().textContent = captain.captainedRounds ? captain.captainedRounds.join(', ') : 'N/A';
                        });
                    } else {
                        const row = topCaptainsTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 6;
                    }

                    // Populate Best Players Table
                    bestPlayersTableBody.innerHTML = '';
                    if (data.bestPlayers && data.bestPlayers.length > 0) {
                        data.bestPlayers.forEach(player => {
                            const row = bestPlayersTableBody.insertRow();
                            row.insertCell().textContent = player.name;
                            row.insertCell().textContent = player.started;
                            row.insertCell().textContent = player.autoSubbed;
                            row.insertCell().textContent = player.pointsGained;
                            row.insertCell().textContent = player.benchedPoints;
                        });
                    } else {
                        const row = bestPlayersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 5;
                    }

                    // Populate Worst Players Table
                    worstPlayersTableBody.innerHTML = '';
                    if (data.worstPlayers && data.worstPlayers.length > 0) {
                        data.worstPlayers.forEach(player => {
                            const row = worstPlayersTableBody.insertRow();
                            row.insertCell().textContent = player.name;
                            row.insertCell().textContent = player.started;
                            row.insertCell().textContent = player.autoSubbed;
                            row.insertCell().textContent = player.pointsGained;
                            row.insertCell().textContent = player.benchedPoints;
                        });
                    } else {
                        const row = worstPlayersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 5;
                    }

                    // Populate Missed Points Table
                    missedPointsTableBody.innerHTML = '';
                    if (data.top5MissedPoints && data.top5MissedPoints.length > 0) {
                        data.top5MissedPoints.forEach(item => {
                            const row = missedPointsTableBody.insertRow();
                            row.insertCell().textContent = item.playerName;
                            row.insertCell().textContent = item.points;
                            row.insertCell().textContent = item.round;
                        });
                    } else {
                        const row = missedPointsTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 3;
                    }

                    // Populate Most Profitable Transfers Table
                    profitableTransfersTableBody.innerHTML = '';
                    if (data.top5ProfitableTransfers && data.top5ProfitableTransfers.length > 0) {
                        data.top5ProfitableTransfers.forEach(transfer => {
                            const row = profitableTransfersTableBody.insertRow();
                            row.insertCell().textContent = transfer.playerInName;
                            row.insertCell().textContent = transfer.playerOutName;
                            row.insertCell().textContent = transfer.round;
                            const profitLossCell = row.insertCell();
                            profitLossCell.textContent = transfer.profitLoss;
                            profitLossCell.classList.add(transfer.profitLoss >= 0 ? 'positive' : 'negative');
                        });
                    } else {
                        const row = profitableTransfersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 4;
                    }

                    // Populate Most Loss-making Transfers Table
                    lossMakingTransfersTableBody.innerHTML = '';
                    if (data.top5LossMakingTransfers && data.top5LossMakingTransfers.length > 0) {
                        data.top5LossMakingTransfers.forEach(transfer => {
                            const row = lossMakingTransfersTableBody.insertRow();
                            row.insertCell().textContent = transfer.playerInName;
                            row.insertCell().textContent = transfer.playerOutName;
                            row.insertCell().textContent = transfer.round;
                            const profitLossCell = row.insertCell();
                            profitLossCell.textContent = transfer.profitLoss;
                            profitLossCell.classList.add(transfer.profitLoss >= 0 ? 'positive' : 'negative');
                        });
                    } else {
                        const row = lossMakingTransfersTableBody.insertRow();
                        row.insertCell().textContent = 'No data available.';
                        row.cells[0].colSpan = 4;
                    }


                    // Render Rank Journey Chart
                    renderRankJourneyChart(data.overallRankHistory);

                    managerStatsDiv.style.display = 'block';

                } else {
                    errorMessage.textContent = data.error || 'An unknown error occurred.';
                    errorMessage.style.display = 'block';
                }

            } catch (error) {
                loadingMessage.style.display = 'none';
                errorMessage.textContent = `Failed to fetch data: ${error.message}. This might be due to a network issue, an invalid Manager ID, or a temporary API problem. Please try again.`;
                errorMessage.style.display = 'block';
                console.error("Fetch error:", error);
            }
        }

        function renderRankJourneyChart(rankData) {
            if (!rankData || rankData.length === 0) {
                console.warn("No rank data to render chart.");
                return;
            }

            // Sort data by round number to ensure correct chart progression
            rankData.sort((a, b) => a.round - b.round);

            // Prepare labels and ranks, filling gaps with null for Chart.js
            const maxRound = Math.max(...rankData.map(d => d.round));
            const labels = Array.from({ length: maxRound + 1 }, (_, i) => `Round ${i}`);
            const ranks = Array(maxRound + 1).fill(null);
            rankData.forEach(d => {
                if (d.round <= maxRound) {
                    ranks[d.round] = d.rank;
                }
            });

            // Filter out 'N/A' or null ranks for determining min/max for Y-axis scaling
            const validRanksForScaling = ranks.filter(rank => typeof rank === 'number' && !isNaN(rank));
            const minRank = validRanksForScaling.length > 0 ? Math.min(...validRanksForScaling) : 1;
            const maxRank = validRanksForScaling.length > 0 ? Math.max(...validRanksForScaling) : 114000; // Default max if no valid ranks

            // Dynamic Y-axis max calculation (similar to previous "old design" logic)
            let overallYAxisMax;
            if (maxRank <= 150) {
                overallYAxisMax = maxRank + 10;
            } else if (maxRank <= 300) {
                overallYAxisMax = maxRank + 25;
            } else {
                overallYAxisMax = maxRank + 50;
            }
            // Ensure a reasonable minimum for the Y-axis max
            overallYAxisMax = Math.max(overallYAxisMax, 200);


            // Animation speed for 5 seconds total (adjust as needed)
            const totalAnimationDurationMs = 5000;
            const numberOfAnimationSteps = labels.length - 1; // Number of segments to animate
            const animationSpeed = numberOfAnimationSteps > 0 ? totalAnimationDurationMs / numberOfAnimationSteps : 0;

            let currentAnimationFrameRound = 0; // Start animation from round 0 (before any data)

            videoLoadingMessage.style.display = 'block'; // Show loading message before animation

            const ctx = rankJourneyChartCanvas.getContext('2d');
            if (rankJourneyChartInstance) {
                rankJourneyChartInstance.destroy(); // Destroy existing chart instance
            }

            rankJourneyChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Overall Rank',
                        data: Array(labels.length).fill(null), // Initialize with nulls for animation
                        tension: 0.1, // Smooth curves
                        spanGaps: true, // Connect gaps where data is null
                        pointRadius: (context) => {
                            // Make point visible only for the current animated round
                            // And only if there's actual data for that point
                            return context.dataIndex === currentAnimationFrameRound && ranks[context.dataIndex] !== null ? 5 : 0;
                        },
                        pointBackgroundColor: 'red',
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        // Dynamic border color based on rank change (from old design)
                        borderColor: (context) => {
                            const currentDataIndex = context.dataIndex;
                            const previousDataIndex = currentDataIndex - 1;

                            // Get the actual data points from the animated dataset
                            const currentRank = context.dataset.data[currentDataIndex];
                            const previousRank = context.dataset.data[previousDataIndex]; 
                            
                            // If previous or current rank is not a valid number, use default color (e.g., for initial point or gaps)
                            if (typeof previousRank !== 'number' || typeof currentRank !== 'number') {
                                return '#007BFF'; // Default blue
                            }

                            if (currentRank < previousRank) { // Rank improved (lower number is better)
                                return '#28A745'; // Green
                            } else if (currentRank > previousRank) { // Rank worsened (higher number is worse)
                                return '#DC3545'; // Red
                            } else { // Rank unchanged
                                return '#495057'; // Grey
                            }
                        },
                        // Dynamic background color based on rank change (matching border)
                        backgroundColor: (context) => {
                            const currentDataIndex = context.dataIndex;
                            const previousDataIndex = currentDataIndex - 1;

                            const currentRank = context.dataset.data[currentDataIndex];
                            const previousRank = context.dataset.data[previousDataIndex];

                            if (typeof previousRank !== 'number' || typeof currentRank !== 'number') {
                                return 'rgba(0, 123, 255, 0.1)'; // Default transparent blue
                            }

                            if (currentRank < previousRank) {
                                return 'rgba(40, 167, 69, 0.1)'; // Green transparent
                            } else if (currentRank > previousRank) {
                                return 'rgba(220, 53, 69, 0.1)'; // Red transparent
                            } else {
                                return 'rgba(73, 80, 87, 0.1)'; // Grey transparent
                            }
                        },
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true, // Crucial for dynamic sizing based on aspect ratio
                    aspectRatio: 2, // Adjust this value to control height relative to width (e.g., 2 for 2:1 width:height)
                    animation: false, // Disable Chart.js built-in animation for custom animation
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#495057'
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat().format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Round',
                                color: '#495057'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                color: '#495057',
                                autoSkip: true,
                                maxTicksLimit: 10 // Limit x-axis ticks for readability
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Overall Rank (Lower is Better)',
                                color: '#495057'
                            },
                            reverse: true, // Lower rank is better, so reverse the Y-axis
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            min: 1, // Always start from rank 1
                            max: overallYAxisMax, // Use dynamically calculated max
                            ticks: {
                                color: '#495057',
                                callback: function(value, index, values) {
                                    return new Intl.NumberFormat().format(value);
                                },
                                maxTicksLimit: window.innerWidth < 768 ? 9 : 11 // Smaller tick labels on mobile
                            }
                        }
                    }
                }
            });

            // Animation Logic
            const maxAnimationRound = labels.length - 1; // Animate up to the last round with data

            function animateRankJourney() {
                if (currentAnimationFrameRound <= maxAnimationRound) {
                    // Update data for the current frame
                    const animatedData = ranks.map((val, idx) => {
                        if (idx < currentAnimationFrameRound) { // Use < to ensure currentAnimationFrameRound is the *next* round to reveal
                            return val;
                        }
                        return null; // Don't show future points yet
                    });

                    rankJourneyChartInstance.data.datasets[0].data = animatedData;
                    rankJourneyChartInstance.update();

                    currentAnimationFrameRound++;
                    setTimeout(animateRankJourney, animationSpeed); // Use the calculated animation speed
                } else {
                    videoLoadingMessage.style.display = 'none'; // Hide loading message
                    // After animation, reset pointRadius to show all points
                    rankJourneyChartInstance.data.datasets[0].pointRadius = 3;
                    rankJourneyChartInstance.update();
                }
            }

            animateRankJourney(); // Start the animation
        }
    </script>
</body>
</html>